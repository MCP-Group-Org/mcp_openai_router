# Описание проблемы

В ноутбуке `mor-python.ipynb` и при вызовах через XAIA-бота сервер `mcp_openai_router` выполняет цепочку `initialize → tools/list → tools/call`. Когда модель Responses API возвращает `tool_call` для инструмента `think`, наш backend должен локально исполнить `think_tool`, затем отправить результат обратно в OpenAI и дождаться финального ответа.

После первых попыток интеграции мы пытались передавать результаты `think_tool` через несуществующий для Responses API метод `responses.submit_tool_outputs`, что приводило к ошибке SDK. Дополнительно API отвергало варианты с `tool_result` и `output_text` в `input[0].content`. В итоге цепочка обрывалась на этапе передачи результата инструмента — модель OpenAI ожидала `function_call_output` для идентификатора вызванного `think`, но не получала его, из-за чего `tools/call` заканчивался MCP-ошибкой «No tool output found for function call …».

# План решения

- Перестроить follow-up в `app/main.py`: после локального исполнения `think_tool` формировать массив `{"type": "function_call_output", "call_id": ..., "output": ...}` и пробрасывать его через `responses.create(...)` с `previous_response_id`.
- Дополнительно проконтролировать, чтобы вывод `think_tool` собрался в строку (с `\n\n` между блоками) и передавался через `call_id` в `function_call_output` с блоком `{"type": "input_text", "text": ...}`.
- После изменения логики перепроверить ноутбук и XAIA-бота — ожидание: модель получит `function_call_output`, сформирует финальный ответ, а MCP вернёт успешный результат.
- Зафиксировать обновлённую схему в тестах и документации, чтобы поведение не регрессировало при обновлениях SDK.

# Следующие шаги

- [ ] Добавить временную диагностику в `_handle_chat`: логировать пары `tool_call.id` → `call_id`, а также финальный `follow_up_payload`, чтобы убедиться, что мы действительно передаём корректный идентификатор и структуру `function_call_output`.
- [ ] Сравнить нормализацию вызовов в `_normalise_responses_output`: убедиться, что при разборе блоков `function_call` мы не теряем поле `id` (при необходимости расширить тестовый мок, чтобы эмулировать реальный формат).
- [ ] Написать минимальный integration-тест (можно в `tests/test_mcp_router.py`), который генерирует ответ с `function_call`, затем проверяет, что наш обработчик формирует follow-up с `call_id` и `input_text`.
- [ ] После исправлений перезапустить `mor-python.ipynb` и прогнать сценарий XAIA-бота, чтобы подтвердить отсутствие ошибки «No tool output found for function call …».
